import { ScriptType } from '../types';

export const generateCleanupScript = (path: string, type: ScriptType): string => {
  const cleanPath = path.trim() || "C:\\path\\to\\file";
  
  if (type === ScriptType.POWERSHELL) {
    return `# ForceDelete Script generated by AI Assistant
$Target = "${cleanPath}"

# Check for Administrator privileges
if (!([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Warning "Script is not running as Administrator. Attempting to elevate..."
    Start-Process powershell.exe -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File \`"$PSCommandPath\`"" -Verb RunAs
    exit
}

Write-Host "Attempting to delete: $Target" -ForegroundColor Cyan

# 1. Take Ownership
Write-Host "[1/3] Taking ownership..." -ForegroundColor Yellow
takeown /F "$Target" /R /A /D Y

# 2. Grant Permissions
Write-Host "[2/3] Granting permissions..." -ForegroundColor Yellow
icacls "$Target" /grant Administrators:F /T /C /Q

# 3. Remove Item
Write-Host "[3/3] Deleting..." -ForegroundColor Red
Remove-Item -Path "$Target" -Recurse -Force -ErrorAction SilentlyContinue

if (Test-Path "$Target") {
    Write-Host "Failed to delete target completely." -ForegroundColor Red
    Start-Sleep -Seconds 5
} else {
    Write-Host "Success! Target deleted." -ForegroundColor Green
    Start-Sleep -Seconds 2
}
`;
  } else {
    return `@echo off
:: ForceDelete Batch Script
:: Check for Admin rights
NET SESSION >nul 2>&1
if %errorLevel% == 0 (
    goto :admin
) else (
    echo Requesting administrative privileges...
    powershell -Command "Start-Process '%~dpnx0' -Verb RunAs"
    exit /b
)

:admin
set "TARGET=${cleanPath}"

echo [1/3] Taking ownership of "%TARGET%"...
takeown /F "%TARGET%" /R /A /D Y

echo [2/3] Granting permissions...
icacls "%TARGET%" /grant Administrators:F /T /C /Q

echo [3/3] Deleting...
:: Check if it's a directory or file
if exist "%TARGET%\" (
    rmdir /s /q "%TARGET%"
) else (
    del /f /q "%TARGET%"
)

if exist "%TARGET%" (
    echo Failed to delete.
) else (
    echo Successfully deleted.
)
pause`;
  }
};

export const generateRegistryFile = (scriptPath: string): string => {
  // We don't use the scriptPath for the registry file as it uses %1 context variable
  // We construct a command that Self-Elevates using Start-Process -Verb RunAs
  
  // Note: We use ''%1'' inside the ArgumentList single-quoted string. 
  // PowerShell parses '' as a literal single quote inside a single-quoted string.
  // This effectively wraps the path in single quotes: $t = 'C:\Path'
  
  return `Windows Registry Editor Version 5.00

; Add to File Context Menu
[HKEY_CLASSES_ROOT\\*\\shell\\ForceDelete]
@="Force Delete (PowerShell)"
"Icon"="imageres.dll,-5304"
"HasLUAShield"=""

[HKEY_CLASSES_ROOT\\*\\shell\\ForceDelete\\command]
@="powershell.exe -WindowStyle Hidden -Command \\"Start-Process powershell -Verb RunAs -ArgumentList '-NoProfile -ExecutionPolicy Bypass -Command & { $t = ''%1''; Write-Host \\\"Target: $t\\\"; takeown /F $t /A /D Y; icacls $t /grant Administrators:F /C /Q; Remove-Item -Path $t -Force; Start-Sleep -Seconds 2 }'\\""

; Add to Directory Context Menu
[HKEY_CLASSES_ROOT\\Directory\\shell\\ForceDelete]
@="Force Delete (PowerShell)"
"Icon"="imageres.dll,-5304"
"HasLUAShield"=""

[HKEY_CLASSES_ROOT\\Directory\\shell\\ForceDelete\\command]
@="powershell.exe -WindowStyle Hidden -Command \\"Start-Process powershell -Verb RunAs -ArgumentList '-NoProfile -ExecutionPolicy Bypass -Command & { $t = ''%1''; Write-Host \\\"Target: $t\\\"; takeown /F $t /R /A /D Y; icacls $t /grant Administrators:F /T /C /Q; Remove-Item -Path $t -Recurse -Force; Start-Sleep -Seconds 2 }'\\""
`;
};